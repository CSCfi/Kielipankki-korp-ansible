---

# Run like:
# ansible-playbook -i inventories/dev/ install-corpus.yml --extra-vars '{"corpus_packages_to_install": ["klk_fi_1881"]}'
#
# If the package name has an ending, like .tgz, the exact file name will
# be installed. Otherwise, we try to find the newest one.
#
# If future_build is true, (also) copy Korp backend corpus
# configurations for the corpora with registry files in the CWB corpus
# registry directory. This can be done without defining
# corpus_packages_to_install. Installing the configurations requires
# that the configuration files have already been installed under
# {{korp_backend_corpusconfig_home}} (in the korp-backend role).

- name: Install a Korp corpus package and backend corpus configurations
  hosts: korp
  become: true

  vars:
    corpus_package_bucket: "korp_corpus_packages"
    s3cmd: "s3cmd --host=a3s.fi --host-bucket='%(bucket)s.a3s.fi'"
    cleanup: true
    package_directory: "/v/corpora/pkgs"
    cwb_registry: "/v/corpora/registry"
  environment:
    AWS_SECRET_ACCESS_KEY: "{{ lookup('passwordstore', 'lb_passwords/korp/allas_robot_ec2_secret') }}"
    AWS_ACCESS_KEY_ID: "{{ lookup('passwordstore', 'lb_passwords/korp/allas_robot_ec2_access') }}"

  tasks:

    - name: Install s3cmd
      ansible.builtin.dnf:
        name:
          - s3cmd

    - name: Ensure pkgs directory
      ansible.builtin.file:
        path: "{{ package_directory }}"
        state: directory
        mode: "u+rwx,g+rwxs,o+rx"
        owner: "root"
        group: "clarin"

    - name: List all available packages in Allas
      command:
        cmd: "{{ s3cmd }} ls s3://{{ corpus_package_bucket }}/"
      register: s3_packages

    - name: Parse available packages
      set_fact:
        available_packages: "{{ s3_packages.stdout_lines | map('regex_search', '([^/\\s]+_korp_\\d{8}_\\d{6}\\..+)$') | select('string') | list }}"

    - name: Initialise package name registry
      set_fact:
        resolved_packages: []
        unresolved_packages: []

    - name: Determine package name for each requested corpus
      set_fact:
        resolved_packages: "{{ resolved_packages + [resolved] }}"
        unresolved_packages: "{{ unresolved_packages + ([item] if resolved == '' else []) }}"
      loop: "{{ corpus_packages_to_install }}"
      vars:
        # Check if item already has timestamp (full filename)
        is_full_name: "{{ item is regex('_korp_\\d{8}_\\d{6}\\.') }}"
        # If full name, use as-is, otherwise find newest
        resolved: "{{ item if is_full_name else (available_packages | select('match', '^' + item + '_korp_') | sort | last | default('')) }}"

    - name: Fail if requests can't be met
      fail:
        msg: "ERROR: Could not find packages for: {{ unresolved_packages | join(', ') }}"
      when: unresolved_packages | length > 0

    - name: Check which packages already exist locally
      stat:
        path: "{{ package_directory }}/{{ item }}"
      loop: "{{ resolved_packages }}"
      register: package_stats
      when: resolved_packages | length > 0

    - name: Fetch missing packages from Allas
      command:
        cmd: "{{ s3cmd }} get s3://{{ corpus_package_bucket }}/{{ item.item }} {{ package_directory }}/"
      loop: "{{ package_stats.results }}"
      when: not item.stat.exists
      loop_control:
        label: "Fetched {{ item.item }}"

    - name: Run korp-install-corpora.sh
      when: resolved_packages | length > 0
      ansible.builtin.command:
        cmd: "./korp-install-corpora.sh {{ package_directory }}/{{ item }}"
        chdir: "{{ korp_utils_root }}/{{ kp_utils_name }}/scripts"
      loop: "{{ resolved_packages }}"
      loop_control:
        label: "Installed {{ item }}"
      register: result
      failed_when:
        - result.rc != 0
        - '"skipping" not in result.stderr'
      environment:
        MYSQL_USER: "root"
        MYSQL_HOST: "{{ korp_db_server }}"
        MYSQL_PASSWORD: "{{ db_root_password }}"

    # Currently, the (future) Korp frontend produces an error if the
    # configuration refers to an unavailable corpus, so the following
    # two tasks install only the configurations of available corpora.
    # If the frontend is modified to automatically filter out
    # unavailable corpora, we could simply install all corpus
    # configurations as a part of the Korp installation.

    - name: Find installed corpora based on CWB registry files
      when: future_build
      ansible.builtin.find:
        paths:
          - "{{ cwb_registry }}"
        patterns:
          - "*"
        excludes:
          - "*~"
          - "*.bak*"
          - "*.old*"
      register: installed_corpora

    - name: Install backend corpus configurations
      when: future_build
      block:
        - name: Check which corpus configs exist
          stat:
            path: "{{ korp_backend_corpusconfig_home }}/corpora/{{ item.split('/') | last }}.yaml"
          loop: "{{ installed_corpora.files | map(attribute='path') }}"
          register: config_stats

        - name: Install backend corpus configurations for installed corpora
          when: future_build and item.stat.exists
          ansible.builtin.copy:
            src: "{{ korp_backend_corpusconfig_home }}/corpora/{{ item.item.split('/') | last }}.yaml"
            dest: "{{ korp_corpus_config_dir }}/corpora/"
            remote_src: true
            force: false
            owner: gunicorn
            group: gunicorn
            mode: "0640"
          loop: "{{ config_stats.results }}"
          loop_control:
            label: "Installed config for {{ item.item.split('/') | last }}"
